package io.sarl.api.protocol.examples.cnp.adapter.participant

import io.sarl.api.core.ExternalContextAccess
import io.sarl.api.localstate.KnowledgeID
import io.sarl.api.localstate.LocalStateManager
import io.sarl.api.protocol.ProtocolMessage
import io.sarl.api.protocol.ProtocolSkill
import io.sarl.api.protocol.examples.cnp.adapter.events.Done
import io.sarl.api.protocol.examples.cnp.adapter.events.Failure
import io.sarl.api.protocol.examples.cnp.adapter.events.Propose
import io.sarl.api.protocol.examples.cnp.adapter.events.Refuse
import java.util.UUID
import java.util.stream.Stream

skill ParticipantProtocolSkill implements ParticipantProtocolCapacity extends ProtocolSkill {
	
	uses LocalStateManager, ExternalContextAccess
	
	synchronized def getEnabledProposeMessages : Stream<ProtocolMessage<Propose>> {
		
		var enabledMessages = <ProtocolMessage<Propose>> newArrayList
		
		var scopes = getScopesFromName("task")
		for(scope : scopes.toList) {
			if (!scope.keys.isEmpty && protocolSpaces.anyMatch[
				 scope.keys.get(0) == it.spaceID as String
			]) {
				//isDefined(new KnowledgeID("p2", scope.keys)
				if(!isBound(new KnowledgeID("offer", scope.keys)) &&
				   !isBound(new KnowledgeID("pdecision", scope.keys))
				) {
					var ^space = protocolSpaces.filter[it.spaceID as String == scope.keys.get(0)].findAny.get
					enabledMessages.add(
						new ProtocolMessage<Propose>(
							^space,
							new Propose(scope.keys.get(0) as String,
										scope.keys.get(1) as String,
										getKnowledge(new KnowledgeID("task", scope.keys), typeof(String))
							),
							getKnowledge(new KnowledgeID("contractor", scope.keys), typeof(UUID))
						)
					)
				}
			}
		}
		return enabledMessages.stream
	}
	
	synchronized def getEnabledRefuseMessages : Stream<ProtocolMessage<Refuse>> {
		var enabledMessages = <ProtocolMessage<Refuse>>newArrayList

		var scopes = getScopesFromName("task")
		for (scope : scopes.toList) {
			if (!scope.keys.isEmpty && protocolSpaces.anyMatch [
				scope.keys.get(0) == it.spaceID as String
			]) {
				// isDefined(new KnowledgeID("p2", scope.keys)
				if (!isBound(new KnowledgeID("outcome", scope.keys)) && 
					!isBound(new KnowledgeID("pdecision", scope.keys))) {
					var ^space = protocolSpaces.filter[it.spaceID as String == scope.keys.get(0)].findAny.get
					enabledMessages.add(
						new ProtocolMessage<Refuse>(
							^space,
							new Refuse(
								scope.keys.get(0) as String,
								scope.keys.get(1) as String,
								getKnowledge(new KnowledgeID("task", scope.keys), typeof(String))
							),
							getKnowledge(new KnowledgeID("contractor", scope.keys), typeof(UUID))
						)
					)
				}
			}
		}
		return enabledMessages.stream
	}
	
	def getEnabledDoneMessages : Stream<ProtocolMessage<Done>> {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def getEnabledFailureMessages : Stream<ProtocolMessage<Failure>> {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	synchronized def sendProposeMessage(m : ProtocolMessage<Propose>) {
		var idPDecision = new KnowledgeID("pdecision", m.evt.iDt, m.evt.iDp)
		var idOffer = new KnowledgeID("offer", m.evt.iDt, m.evt.iDp)
		var pDecision = getKnowledge(idPDecision, typeof(String))
		var offer = getKnowledge(idOffer, typeof(int))
		bind(idPDecision)
		bind(idOffer)
		m.evt.pDecision = pDecision
		m.evt.offer = offer
		emit(m.^space, m.evt)[it.ID == m.receiver]
	}
	
	synchronized def sendRefuseMessage(m : ProtocolMessage<Refuse>) {
		var idPDecision = new KnowledgeID("pdecision", m.evt.iDt, m.evt.iDp)
		var idOutcome = new KnowledgeID("outcome", m.evt.iDt, m.evt.iDp)
		var pDecision = getKnowledge(idPDecision, typeof(String))
		var outcome = getKnowledge(idOutcome, typeof(String))
		bind(idPDecision)
		bind(idOutcome)
		m.evt.pDecision = pDecision
		m.evt.outcome = outcome
		emit(m.^space, m.evt)[it.ID == m.receiver]
	}
	
	def sendDoneMessage(m : ProtocolMessage<Done>) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def sendFailureMessage(m : ProtocolMessage<Failure>) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
}
